<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Ancient Indoor Temple - Dimmed Lighting</title>
<style>
body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
#instructions {
position: absolute;
top: 10px;
left: 10px;
color: white;
background: rgba(0,0,0,0.7);
padding: 10px;
border-radius: 5px;
z-index: 100;
}
#crosshair {
position: absolute;
top: 50%;
left: 50%;
width: 4px;
height: 4px;
background: white;
border-radius: 50%;
transform: translate(-50%, -50%);
z-index: 100;
display: none;
}

/* New CSS for floating text container */
#floatingTextContainer {
position: absolute;
top: 0;
left: 0;
pointer-events: none; /* Allows clicks to pass through */
z-index: 10;
}

.floating-text {
position: absolute;
background: rgba(0, 0, 0, 0.85); /* Slightly darker background for the panel */
color: white;
padding: 10px 15px; /* Increased padding for a panel look */
border-radius: 8px; /* More rounded corners for the panel */
font-size: 15px; /* Slightly larger font */
white-space: nowrap; /* Prevents text from wrapping */
transform: translate(-50%, -120%); /* Adjust to center above object and give more space */
display: none; /* Hidden by default */
border: 1px solid rgba(255, 255, 255, 0.3); /* Subtle white border */
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Add a subtle shadow */
}
</style>
</head>
<body>
<div id="instructions">WASD to move<br>Click to enable mouse look<br>ESC to exit</div>
<div id="crosshair"></div>
<button id="goToFirst" style="
display: none;
position: absolute;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
padding: 10px 20px;
font-size: 18px;
background-color: #00aaff;
color: white;
border: none;
border-radius: 5px;
cursor: pointer;
z-index: 100;
">
Go to First Floor
</button>

<div id="floatingTextContainer"></div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/RGBELoader.js"></script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true }); // Added antialiasing
renderer.setSize(window.innerWidth, window.innerHeight);

// --- Renderer Configuration for PBR and Shadows ---

// --- Renderer Configuration for PBR and Shadows ---
renderer.outputEncoding = THREE.sRGBEncoding; // For correct color space with HDRIs
renderer.toneMapping = THREE.ACESFilmicToneMapping; // Recommended tone mapping for HDRIs
renderer.toneMappingExposure = 0.6; // *** REDUCED EXPOSURE *** (Adjust this first!)
renderer.shadowMap.enabled = true; // Enable shadow maps
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows

document.body.appendChild(renderer.domElement);

// --- HDRI Environment for Indoor Scene ---
new THREE.RGBELoader()
    .setPath('./') // Set the path where your HDRI file is located
    .load('fireplace_4k.hdr', function (texture) { // Indoor HDRI for an ancient hall
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = texture; // Provides lighting and reflections for PBR materials
        // scene.background = texture; // <<< COMMENT OUT THIS LINE IN INDEX.HTML
    },
    (progress) => {
        // console.log(`HDRI loading: ${Math.round(progress.loaded / progress.total * 100)}%`);
    },
    (error) => {
        console.error('Error loading HDRI:', error);
        // Fallback lighting if HDRI fails to load
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    });

// --- Lighting for Indoor Temple ---
// --- REDUCED AMBIENT LIGHT ---
scene.add(new THREE.AmbientLight(0xffffff, 0.08)); // Very subtle ambient light

// --- Point Lights (simulating torches, lamps, or light from openings) ---
// --- REDUCED INTENSITIES AND DISTANCES ---
const pointLight1 = new THREE.PointLight(0xffd700, 0.8, 10); // Warm, golden light (like a torch), shorter distance
pointLight1.position.set(-8, 2, -8); // Near one of the tables
pointLight1.castShadow = true;
pointLight1.shadow.mapSize.width = 1024;
pointLight1.shadow.mapSize.height = 1024;
pointLight1.shadow.camera.near = 0.1;
pointLight1.shadow.camera.far = 15; // Shorter shadow camera far plane
scene.add(pointLight1);

const pointLight2 = new THREE.PointLight(0xffd700, 0.8, 10);
pointLight2.position.set(8, 2, 8); // Near another table
pointLight2.castShadow = true;
pointLight2.shadow.mapSize.width = 1024;
pointLight2.shadow.mapSize.height = 1024;
pointLight2.shadow.camera.near = 0.1;
pointLight2.shadow.camera.far = 15;
scene.add(pointLight2);

// Optionally, add a light near the entrance/stairs to simulate light from outside
const entranceLight = new THREE.PointLight(0xabcdef, 0.6, 15); // Cooler light for natural light, shorter distance
entranceLight.position.set(-4, 2, -10); // Near the back wall/entrance
entranceLight.castShadow = true;
entranceLight.shadow.mapSize.width = 1024;
entranceLight.shadow.mapSize.height = 1024;
entranceLight.shadow.camera.near = 0.1;
entranceLight.shadow.camera.far = 20;
scene.add(entranceLight);

// Floor (will receive shadows)
const groundTextureLoader = new THREE.TextureLoader();
const groundTexture = groundTextureLoader.load('floor.jpg');
groundTexture.wrapS = THREE.RepeatWrapping;
groundTexture.wrapT = THREE.RepeatWrapping;
groundTexture.repeat.set(4, 4);

const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 20),
    new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 0.8, metalness: 0.05 }) // High roughness for aged stone
);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);


// Walls (will cast and receive shadows)
const walls = [];
const textureLoader = new THREE.TextureLoader();
const wallTexture = textureLoader.load('walls.jpg');
wallTexture.wrapS = THREE.RepeatWrapping;
wallTexture.wrapT = THREE.RepeatWrapping;
wallTexture.repeat.set(2, 1);

const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.9, metalness: 0 }); // Higher roughness for ancient, unpolished stone

function addWall(x, z, rotY = 0) {
    const wall = new THREE.Mesh(new THREE.BoxGeometry(20, 4, 0.2), wallMaterial);
    wall.position.set(x, 2, z);
    wall.rotation.y = rotY;
    wall.castShadow = true;
    wall.receiveShadow = true;
    scene.add(wall);
    walls.push(wall);
}
addWall(0, -10); addWall(0, 10); addWall(-10, 0, Math.PI/2); addWall(10, 0, Math.PI/2);

// First floor platform (as part of the temple structure) - will cast and receive shadows
const firstFloorTexture = textureLoader.load('floor.jpg');
firstFloorTexture.wrapS = THREE.RepeatWrapping;
firstFloorTexture.wrapT = THREE.RepeatWrapping;
firstFloorTexture.repeat.set(10, 10);

const firstFloor = new THREE.Mesh(
    new THREE.BoxGeometry(100, 0.2, 100),
    new THREE.MeshStandardMaterial({ map: firstFloorTexture, roughness: 0.7, metalness: 0.05 })
);
firstFloor.position.set(0, 4.1, 0);
firstFloor.castShadow = true;
firstFloor.receiveShadow = true;
scene.add(firstFloor);


// Staircase (will cast and receive shadows)
const stairMaterial = new THREE.MeshStandardMaterial({ color: 0x887766, roughness: 0.7, metalness: 0 });
const stairCount = 8, stairWidth = 2, stairDepth = 1, stairHeight = 0.5;
for (let i = 0; i < stairCount; i++) {
    const step = new THREE.Mesh(
        new THREE.BoxGeometry(stairWidth, stairHeight, stairDepth),
        stairMaterial
    );
    step.position.set(-4, (i + 0.5) * stairHeight, -4 + i * stairDepth);
    step.castShadow = true;
    step.receiveShadow = true;
    scene.add(step);
    walls.push(step); // for collision
}

// Table (Rigid) - Pedestal (will cast and receive shadows)
const tableTop = new THREE.Mesh(
    new THREE.CylinderGeometry(1.5, 1.5, 0.1, 32),
    new THREE.MeshStandardMaterial({ color: 0x6B4226, roughness: 0.6, metalness: 0.1 })
);
tableTop.position.set(0, 1, 0);
tableTop.castShadow = true;
tableTop.receiveShadow = true;
scene.add(tableTop);
walls.push(tableTop);

const tableLeg = new THREE.Mesh(
    new THREE.CylinderGeometry(0.2, 0.2, 1, 16),
    new THREE.MeshStandardMaterial({ color: 0x2A1B0C, roughness: 0.7, metalness: 0.1 })
);
tableLeg.position.set(0, 0.5, 0);
tableLeg.castShadow = true;
tableLeg.receiveShadow = true;
scene.add(tableLeg);
walls.push(tableLeg);

// Array to store spotlights for the models
const modelSpotlights = [];


// Place model on center table
placeGLBModelAt(0, 1.05, 0, 'center1.glb', 0.5, 0, 'Center Ganesha'); // Added infoText for the center model
placeGLBModelAt(0.3, 1.1, 1, 'fruit.glb', 0.1, 0);


function createSquareTable(x, z) {
    // Top
    const top = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.1, 2),
        new THREE.MeshStandardMaterial({ color: 0x6B4226, roughness: 0.6, metalness: 0.1 })
    );
    top.position.set(x, 1, z);
    top.castShadow = true;
    top.receiveShadow = true;
    scene.add(top);
    walls.push(top); // For collision

    // Legs
    const legGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
    const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2A1B0C, roughness: 0.7, metalness: 0.1 });

    const offsets = [
        [0.9, 0.9],
        [-0.9, 0.9],
        [0.9, -0.9],
        [-0.9, -0.9],
    ];

    for (let [dx, dz] of offsets) {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(x + dx, 0.5, z + dz);
        leg.castShadow = true;
        leg.receiveShadow = true;
        scene.add(leg);
        walls.push(leg);
    }
}


function placeGLBModelAt(x, y, z, modelPath, scale = 0.01, rotationY = 0, infoText = '') {
    const loader = new THREE.GLTFLoader();
    loader.load(modelPath, (gltf) => {
        const model = gltf.scene;

        model.scale.set(scale, scale, scale);
        model.position.set(x, y, z);
        model.rotation.y = rotationY;

        model.traverse((child) => {
            if (child.isMesh) {
                if (child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial) {
                    // These materials automatically pick up scene.environment
                }
                child.castShadow = true;    // Models cast shadows
                child.receiveShadow = true; // Models receive shadows

                child.userData.originalMaterial = child.material;
                child.userData.glowMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffff66,
                    emissive: 0xffff00,
                });
            }
        });

        scene.add(model);
        walls.push(model);

        interactiveGLBs.set(model.uuid, { model: model, info: infoText });

        // *** ADDING SPOTLIGHT TO THE GLB MODEL ***
        // Only add a spotlight if infoText is provided (assuming it's a Ganesha model)
        if (infoText) {
            const spotlight = new THREE.SpotLight(0xffffff, 1.5, 10, Math.PI / 8, 0.5, 0.5); // Color, intensity, distance, angle, penumbra, decay
            spotlight.position.set(x, y + 3, z); // Position the spotlight above the model
            spotlight.target = model; // Make the spotlight point at the model

            spotlight.castShadow = true;
            spotlight.shadow.mapSize.width = 1024;
            spotlight.shadow.mapSize.height = 1024;
            spotlight.shadow.camera.near = 0.5;
            spotlight.shadow.camera.far = 10;
            spotlight.shadow.camera.fov = 30; // Narrower FOV for more focused shadow

            scene.add(spotlight);
            scene.add(spotlight.target); // Add the target to the scene for it to work

            modelSpotlights.push({ model: model, spotlight: spotlight }); // Store for potential updates
        }

    }, undefined, (err) => {
        console.g2('Error loading ${modelPath}', err);
    });
}


// Create tables and place models at corners
createSquareTable(-8, -8);
placeGLBModelAt(-8, 1.05, -8, 'g2.glb',0.1,0,'Bala Ganapthi:Bala Ganapati is “the Childlike” God of golden hue');

createSquareTable(-8, 8);
placeGLBModelAt(-8, 1.05, 8, 'g3.glb',0.1,Math.PI/2,'Vighna ganpathi:Vighna Ganapati, “Lord of Obstacles,” is of brilliant gold hue and bedecked in jewels');

createSquareTable(8, -8);
placeGLBModelAt(8, 1.05, -8, 'sculpture.glb',0.01,0,'shakti ganapathi:Four-armed and seated with one of His shaktis on His knee, Shakti Ganapati, “the Powerful,” of orange-red hue, guards the householder. ');

createSquareTable(8, 8);
placeGLBModelAt(8, 1.05, 8, 'g1.glb',0.7,-Math.PI/2,'siddhi ganpathi:Golden-yellow Siddhi Gaṇapati, “the Accomplished,” is the epitome of achievement and self-mastery');



// 🧺 Fruit GLBs in front of each table (slightly outward direction)
placeGLBModelAt(-8, 1.05, -7, 'fruit.glb', 0.3, 0);
placeGLBModelAt(-8, 1.05, 10, 'fruit2.glb', 0.1, 0);
placeGLBModelAt(8, 1.05, -10, 'fruit3.glb', 0.1, 0);
placeGLBModelAt(8, 1.05, 10, 'fruit4.glb', 0.1, 0);


// Camera
camera.position.set(0, 2, 5);
camera.lookAt(0, 2, 0);

// Controls
const keys = {};
document.addEventListener("keydown", (e) => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);

let isPointerLocked = false;
const euler = new THREE.Euler(0, 0, 0, 'YXZ');
const PI_2 = Math.PI / 2;

function onMouseMove(event) {
if (!isPointerLocked) return;
const movementX = event.movementX || 0;
const movementY = event.movementY || 0;
euler.setFromQuaternion(camera.quaternion);
euler.y -= movementX * 0.002;
euler.x -= movementY * 0.002;
euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
camera.quaternion.setFromEuler(euler);
}

function onPointerLockChange() {
isPointerLocked = document.pointerLockElement === document.body;
document.getElementById('crosshair').style.display = isPointerLocked ? 'block' : 'none';
}

function onPointerLockError() {
console.error('Pointer lock failed');
}

document.addEventListener('mousemove', onMouseMove);
document.addEventListener('pointerlockchange', onPointerLockChange);
document.addEventListener('pointerlockerror', onPointerLockError);


document.addEventListener('click', () => {
if (!isPointerLocked) document.body.requestPointerLock();

const music = document.getElementById('bg-music');
music.play().catch(err => console.log('Autoplay blocked:', err));
});

document.addEventListener('keydown', (e) => {
if (e.key === 'Escape') document.exitPointerLock();
});

// Collision
function isColliding(pos) {
const playerBox = new THREE.Box3().setFromCenterAndSize(
pos.clone(), new THREE.Vector3(0.8, 2, 0.8)
);
for (let obj of walls) {
const box = new THREE.Box3().setFromObject(obj);
if (box.intersectsBox(playerBox)) return true;
}
return false;
}

// ✅ Button logic for first floor
const goToFirstBtn = document.getElementById("goToFirst");
goToFirstBtn.addEventListener('click', () => {
window.location.href = "firstfloor.html"; // Replace if needed
});


const raycaster = new THREE.Raycaster();
const interactiveGLBs = new Map(); // key: model.uuid, value: { model: THREE.Object3D, info: string }

// --- Floating Text Manager ---
class FloatingTextManager {
constructor(containerId, camera, renderer) {
this.container = document.getElementById(containerId);
this.camera = camera;
this.renderer = renderer;
this.activeTextElement = null;
this.activeModel = null;
}

showText(model, text) {
if (this.activeTextElement) {
if (this.activeModel === model && this.activeTextElement.textContent === text) {
return;
}
this.activeTextElement.remove();
}

const textElement = document.createElement('div');
textElement.className = 'floating-text';
textElement.textContent = text;
this.container.appendChild(textElement);
this.activeTextElement = textElement;
this.activeModel = model;
this.updateTextPosition();
}

hideText() {
if (this.activeTextElement) {
this.activeTextElement.remove();
this.activeTextElement = null;
this.activeModel = null;
}
}

updateTextPosition() {
if (this.activeTextElement && this.activeModel) {
const vector = new THREE.Vector3();
const box = new THREE.Box3().setFromObject(this.activeModel);
box.getCenter(vector);
vector.y += (box.max.y - box.min.y) * 0.75;

vector.project(this.camera);

const x = (vector.x * 0.5 + 0.5) * this.renderer.domElement.clientWidth;
const y = (-vector.y * 0.5 + 0.5) * this.renderer.domElement.clientHeight;

this.activeTextElement.style.display = 'block';
this.activeTextElement.style.left = `${x}px`;
this.activeTextElement.style.top = `${y}px`;
}
}

update() {
this.updateTextPosition();
}
}

const floatingTextManager = new FloatingTextManager('floatingTextContainer', camera, renderer);


// Animate
function animate() {
requestAnimationFrame(animate);

const speed = 0.1;
const direction = new THREE.Vector3();
if (keys['w']) direction.z -= 1;
if (keys['s']) direction.z += 1;
if (keys['a']) direction.x -= 1;
if (keys['d']) direction.x += 1;

if (direction.lengthSq() > 0) {
direction.normalize().applyEuler(camera.rotation).multiplyScalar(speed);
const futurePos = camera.position.clone().add(direction);
const checkPos = new THREE.Vector3(futurePos.x, camera.position.y, futurePos.z);
if (!isColliding(checkPos)) {
camera.position.copy(futurePos);
}
}

// Floor snapping
const raycasterFloor = new THREE.Raycaster(
new THREE.Vector3(camera.position.x, camera.position.y + 1, camera.position.z),
new THREE.Vector3(0, -1, 0)
);
const hits = raycasterFloor.intersectObjects(scene.children, true);
if (hits.length > 0) {
const y = hits[0].point.y;
camera.position.y = y + 1.6;
}
// Show "Go to First Floor" button when player is near the stairs
const distanceToStair = camera.position.distanceTo(new THREE.Vector3(-4, camera.position.y, -4));
if (distanceToStair < 2 && camera.position.y < 3) {
goToFirstBtn.style.display = 'block';
} else {
goToFirstBtn.style.display = 'none';
}

// Raycast for interactive objects and display floating text
if (isPointerLocked) {
raycaster.setFromCamera({ x: 0, y: 0 }, camera); // Center of the screen
const intersects = raycaster.intersectObjects(scene.children, true);

let foundInteractiveObject = false;
for (const intersect of intersects) {
let model = intersect.object;
while (model && !interactiveGLBs.has(model.uuid)) {
model = model.parent;
}

const interactiveData = interactiveGLBs.get(model ? model.uuid : null);
if (interactiveData && interactiveData.info) {
floatingTextManager.showText(interactiveData.model, interactiveData.info);
foundInteractiveObject = true;
break;
}
}

if (!foundInteractiveObject) {
floatingTextManager.hideText();
}
} else {
floatingTextManager.hideText();
}

floatingTextManager.update();

renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();

</script>
<audio id="bg-music" src="ganesh.mp3" autoplay loop></audio>

</body>
</html>
